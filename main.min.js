"use strict";
(() => {
  // scripts/dest/Common.js
  var canvasSize = 20;
  var inType = "in";
  var outType = "out";
  var afterDragUpdaters = [];
  function StyleIdForDataType(dataType) {
    switch (dataType) {
      case "int":
        return 2;
      case "int64":
        return 3;
      case "int32":
        return 4;
      case "int16":
        return 5;
      case "int8":
        return 6;
      case "uint":
        return 7;
      case "uint64":
        return 8;
      case "uint32":
        return 9;
      case "uint16":
        return 10;
      case "uint8":
        return 11;
      case "byte":
        return 12;
      case "string":
        return 13;
      case "bool":
        return 14;
      case "float64":
        return 15;
      case "float32":
        return 16;
      case "date":
        return 17;
    }
    return 2;
  }
  function ApplyStyle(ctx, styleId) {
    switch (styleId) {
      case 0: {
        ctx.strokeStyle = "white";
        ctx.fillStyle = "white";
        break;
      }
      case 1: {
        ctx.strokeStyle = "#b0b0b010";
        ctx.fillStyle = "#b0b0b070";
        break;
      }
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12: {
        ctx.strokeStyle = "red";
        ctx.fillStyle = "red";
        break;
      }
      case 13: {
        ctx.strokeStyle = "blue";
        ctx.fillStyle = "blue";
        break;
      }
      case 14: {
        ctx.strokeStyle = "pink";
        ctx.fillStyle = "pink";
        break;
      }
      case 15:
      case 16: {
        ctx.strokeStyle = "purple";
        ctx.fillStyle = "purple";
        break;
      }
      case 17: {
        ctx.strokeStyle = "yellow";
        ctx.fillStyle = "yellow";
        break;
      }
    }
  }
  function ApplySize(canvas, size) {
    canvas.width = size;
    canvas.height = size;
  }
  function AfterDrag() {
    for (let updater of afterDragUpdaters) {
      updater.Update();
    }
  }
  function DragElement(element) {
    var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    document.getElementById(element.id + "-header").onmousedown = dragMouseDown;
    function dragMouseDown(e) {
      e.preventDefault();
      pos3 = e.clientX;
      pos4 = e.clientY;
      document.onmouseup = closeDragElement;
      document.onmousemove = elementDrag;
    }
    function elementDrag(e) {
      e.preventDefault();
      pos1 = pos3 - e.clientX;
      pos2 = pos4 - e.clientY;
      pos3 = e.clientX;
      pos4 = e.clientY;
      element.style.top = element.offsetTop - pos2 + "px";
      element.style.left = element.offsetLeft - pos1 + "px";
      AfterDrag();
    }
    function closeDragElement() {
      document.onmouseup = null;
      document.onmousemove = null;
    }
  }
  function IsNodeOrChildOfNode(target) {
    for (const node of document.getElementsByClassName("node")) {
      if (IsElementOrChild(target, node)) {
        return true;
      }
    }
    return false;
  }
  function IsElementOrChild(wanted, element) {
    if (wanted == element) {
      return true;
    }
    if (!element.hasChildNodes()) {
      return false;
    }
    for (const child of element.children) {
      if (IsElementOrChild(wanted, child)) {
        return true;
      }
    }
    return false;
  }

  // scripts/dest/Line.js
  var lineAmount = 0;
  var LinesMap = /* @__PURE__ */ new Map();
  var Line = class {
    constructor(start, end, startId, style) {
      this.EndId = "";
      this.id = "line" + ++lineAmount;
      this.Start = start;
      this.End = end;
      this.canvas = document.createElement("canvas");
      this.startId = startId;
      this.style = style;
      this.canvas.id = this.id;
      this.canvas.style.position = "absolute";
      this.canvas.style.left = start.X - 30 + "px";
      this.canvas.style.top = start.Y - 30 + "px";
      this.canvas.width = Math.abs(end.X - start.X) * 2;
      this.canvas.height = Math.abs(end.Y - start.Y) * 2;
      document.body.appendChild(this.canvas);
      this.Draw();
      LinesMap.set(this.id, this);
    }
    Draw() {
      this.Clear();
      const width = Math.abs(this.End.X - this.Start.X) * 2;
      const height = Math.abs(this.End.Y - this.Start.Y) * 2;
      this.canvas.width = width + 200;
      this.canvas.height = height + 100;
      this.canvas.style.left = this.Start.X - this.canvas.width / 2 + "px";
      this.canvas.style.top = this.Start.Y - this.canvas.height / 2 + "px";
      const ctx = this.canvas.getContext("2d");
      ApplyStyle(ctx, this.style);
      ctx.lineWidth = 3;
      let x1 = this.canvas.width / 2, y1 = this.canvas.height / 2, x2 = x1 + this.End.X - this.Start.X, y2 = y1 + this.End.Y - this.Start.Y;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      if (x1 >= x2) {
        let xDistance = (x1 - x2) / 2;
        let x3 = x1 - xDistance;
        let y3 = y2 - (y2 - y1) / 2;
        xDistance = xDistance > 40 ? 80 : xDistance * 2;
        ctx.bezierCurveTo(x1 + xDistance, y1, x1 + xDistance, y3, x3, y3);
        ctx.bezierCurveTo(x2 - xDistance, y3, x2 - xDistance, y2, x2, y2);
      } else {
        ctx.bezierCurveTo(x1 + (x2 - x1) / 4 * 3, y1, x1 + (x2 - x1) / 4, y2, x2, y2);
      }
      ctx.stroke();
    }
    Element() {
      return this.canvas;
    }
    Clear() {
      const ctx = this.canvas.getContext("2d");
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    Remove() {
      this.canvas.parentElement.removeChild(this.canvas);
      LinesMap.delete(this.id);
    }
    Id() {
      return this.id;
    }
    StartId() {
      return this.startId;
    }
  };

  // scripts/dest/Point.js
  var Point = class {
    constructor(x, y) {
      this.X = x;
      this.Y = y;
    }
  };

  // scripts/dest/Arrow.js
  var arrowAmount = 0;
  var ArrowsMap = /* @__PURE__ */ new Map();
  var Arrow = class {
    constructor(parent) {
      this.style = 0;
      this.lineId = "";
      this.id = "arrow" + ++arrowAmount;
      this.type = parent.dataset.type;
      this.parent = parent;
      this.canvas = document.createElement("canvas");
      this.canvas.id = this.id;
      this.canvas.dataset.object = "arrow";
      ApplySize(this.canvas, canvasSize * 3);
      this.canvas.classList.add("canvasargument");
      parent.appendChild(this.canvas);
      this.Draw();
      ArrowsMap.set(this.id, this);
      if (this.type == outType) {
        this.connectable();
      }
      afterDragUpdaters.push(this);
    }
    Draw() {
      this.Clear();
      const ctx = this.canvas.getContext("2d");
      ApplyStyle(ctx, 0);
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(10, 10);
      ctx.lineTo(30, 10);
      ctx.lineTo(50, 30);
      ctx.lineTo(30, 50);
      ctx.lineTo(10, 50);
      ctx.lineTo(10, 10);
      if (this.isConnected()) {
        ctx.fill();
      } else {
        ctx.stroke();
      }
    }
    Element() {
      return this.canvas;
    }
    isConnected() {
      return this.lineId != "";
    }
    canConnect() {
      return this.type == inType && !this.isConnected();
    }
    canConnectTo(arrow) {
      return this.parent.id.slice(0, 5) != arrow.parent.id.slice(0, 5) && this.canConnect();
    }
    Clear() {
      const ctx = this.canvas.getContext("2d");
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    Id() {
      return this.id;
    }
    Update() {
      if (this.lineId == "") {
        return;
      }
      const line = LinesMap.get(this.lineId);
      const sourceObject = ArrowsMap.get(line.StartId());
      const srcBoundingCLient = sourceObject.canvas.getBoundingClientRect();
      const fromX = srcBoundingCLient.left + window.scrollX + sourceObject.canvas.offsetWidth / 2;
      const fromY = srcBoundingCLient.top + window.scrollY + sourceObject.canvas.offsetHeight / 2;
      line.Start = new Point(fromX, fromY);
      const destinationObject = ArrowsMap.get(line.EndId);
      const destBoundingCLient = destinationObject.canvas.getBoundingClientRect();
      const toX = destBoundingCLient.left + window.scrollX + destinationObject.canvas.offsetWidth / 2;
      const toY = destBoundingCLient.top + window.scrollY + destinationObject.canvas.offsetHeight / 2;
      line.End = new Point(toX, toY);
      line.Draw();
    }
    getObjectByPoint(point, toArrow) {
      for (const [_, arrow] of ArrowsMap) {
        const boundingCLient = arrow.canvas.getBoundingClientRect();
        if (arrow.canConnectTo(toArrow) && point.X > boundingCLient.left + window.scrollX && point.X < boundingCLient.right + window.scrollX && point.Y > boundingCLient.top + window.scrollY && point.Y < boundingCLient.bottom + window.scrollY) {
          return arrow;
        }
      }
      return null;
    }
    draggable(line) {
      document.onmousemove = elementDrag;
      function elementDrag(e) {
        e.preventDefault();
        line.End = new Point(e.clientX, e.clientY);
        line.Draw();
      }
    }
    closeDraggable(line) {
      const sourceObject = this;
      document.onmouseup = closeDragElement;
      function closeDragElement(e) {
        const destinationObject = sourceObject.getObjectByPoint(new Point(e.clientX, e.clientY), ArrowsMap.get(line.StartId()));
        if (destinationObject != null) {
          const boundingCLient = destinationObject.canvas.getBoundingClientRect();
          const toX = boundingCLient.left + window.scrollX + sourceObject.canvas.offsetWidth / 2;
          const toY = boundingCLient.top + window.scrollY + sourceObject.canvas.offsetHeight / 2;
          line.End = new Point(toX, toY);
          line.Draw();
          line.EndId = destinationObject.id;
          destinationObject.lineId = line.Id();
          destinationObject.Draw();
          destinationObject.disconnectable();
        } else {
          line.Remove();
          if (line.StartId() != "") {
            const startObject = ArrowsMap.get(line.StartId());
            startObject.lineId = "";
            startObject.Draw();
          }
        }
        document.onmouseup = null;
        document.onmousemove = null;
      }
    }
    connectable() {
      const sourceObject = this;
      sourceObject.canvas.onmousedown = connectableMouseDown;
      let boundingCLient = sourceObject.canvas.getBoundingClientRect();
      let line;
      function connectableMouseDown(e) {
        e.preventDefault();
        if (sourceObject.isConnected() && LinesMap.get(sourceObject.lineId) != null) {
          return;
        }
        boundingCLient = sourceObject.canvas.getBoundingClientRect();
        const fromX = boundingCLient.left + window.scrollX + sourceObject.canvas.offsetWidth / 2;
        const fromY = boundingCLient.top + window.scrollY + sourceObject.canvas.offsetHeight / 2;
        line = new Line(new Point(fromX, fromY), new Point(e.clientX, e.clientY), sourceObject.id, sourceObject.style);
        LinesMap.set(line.Id(), line);
        sourceObject.lineId = line.Id();
        sourceObject.Draw();
        sourceObject.closeDraggable(line);
        sourceObject.draggable(line);
      }
    }
    disconnectable() {
      const sourceObject = this;
      sourceObject.canvas.onmousedown = disconnectableMouseDown;
      const line = LinesMap.get(sourceObject.lineId);
      if (line == null) {
        sourceObject.lineId = "";
        sourceObject.canvas.onmousedown = null;
        return;
      }
      function disconnectableMouseDown(e) {
        e.preventDefault();
        if (!sourceObject.isConnected()) {
          sourceObject.canvas.onmousedown = null;
          return;
        }
        sourceObject.lineId = "";
        sourceObject.Draw();
        sourceObject.closeDraggable(line);
        sourceObject.draggable(line);
        sourceObject.canvas.onmousedown = null;
      }
    }
  };

  // scripts/dest/Argument.js
  var argumentAmount = 0;
  function NextArgument() {
    return "argument" + ++argumentAmount;
  }
  var Div = class {
    constructor(parent, cssClasses = []) {
      this.element = document.createElement("div");
      this.element.classList.add(...cssClasses);
      parent.appendChild(this.element);
    }
    Element() {
      return this.element;
    }
  };
  var Label = class {
    constructor(parent, inner, forId = "") {
      const label = document.createElement("label");
      label.innerHTML = inner;
      label.setAttribute("for", forId);
      parent.appendChild(label);
    }
  };

  // scripts/dest/Circle.js
  var circleAmount = 0;
  var CirclesMap = /* @__PURE__ */ new Map();
  var Circle = class {
    constructor(parent, type, owner, signature, dataType) {
      this.lineId = "";
      this.id = "circle" + ++circleAmount;
      this.type = type;
      this.style = StyleIdForDataType(dataType);
      this.owner = owner;
      this.signature = signature;
      document.createElement("div");
      this.canvas = document.createElement("canvas");
      this.canvas.id = this.id;
      this.canvas.dataset.object = "circle";
      ApplySize(this.canvas, canvasSize * 3);
      this.canvas.classList.add("canvasargument");
      parent.appendChild(this.canvas);
      this.Draw();
      CirclesMap.set(this.id, this);
      if (this.type == outType) {
        this.connectable();
      }
      afterDragUpdaters.push(this);
    }
    Draw() {
      this.Clear();
      const ctx = this.canvas.getContext("2d");
      ApplyStyle(ctx, this.style);
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(canvasSize * 1.5, canvasSize * 1.5, canvasSize, 0, 2 * Math.PI);
      if (this.isConnected()) {
        ctx.fill();
      } else {
        ctx.stroke();
      }
    }
    isConnected() {
      return this.lineId != "";
    }
    canConnect() {
      return this.type == inType && !this.isConnected();
    }
    canConnectTo(circle) {
      return this.signature != circle.signature && this.style == circle.style && this.canConnect();
    }
    Element() {
      return this.canvas;
    }
    Clear() {
      const ctx = this.canvas.getContext("2d");
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    Remove() {
      CirclesMap.delete(this.id);
      this.owner.OnRemove();
    }
    Id() {
      return this.id;
    }
    Update() {
      if (this.lineId == "") {
        return;
      }
      const line = LinesMap.get(this.lineId);
      const sourceObject = CirclesMap.get(line.StartId());
      const srcBoundingCLient = sourceObject.canvas.getBoundingClientRect();
      const fromX = srcBoundingCLient.left + window.scrollX + sourceObject.canvas.offsetWidth / 2;
      const fromY = srcBoundingCLient.top + window.scrollY + sourceObject.canvas.offsetHeight / 2;
      line.Start = new Point(fromX, fromY);
      const destinationObject = CirclesMap.get(line.EndId);
      const destBoundingCLient = destinationObject.canvas.getBoundingClientRect();
      const toX = destBoundingCLient.left + window.scrollX + destinationObject.canvas.offsetWidth / 2;
      const toY = destBoundingCLient.top + window.scrollY + destinationObject.canvas.offsetHeight / 2;
      line.End = new Point(toX, toY);
      line.Draw();
    }
    getObjectByPoint(point, toCircle) {
      for (const [_, circle] of CirclesMap) {
        const boundingCLient = circle.canvas.getBoundingClientRect();
        if (circle.canConnectTo(toCircle) && point.X > boundingCLient.left + window.scrollX && point.X < boundingCLient.right + window.scrollX && point.Y > boundingCLient.top + window.scrollY && point.Y < boundingCLient.bottom + window.scrollY) {
          return circle;
        }
      }
      return null;
    }
    draggable(line) {
      document.onmousemove = elementDrag;
      function elementDrag(e) {
        e.preventDefault();
        line.End = new Point(e.clientX, e.clientY);
        line.Draw();
      }
    }
    closeDraggable(line) {
      const sourceObject = this;
      document.onmouseup = closeDragElement;
      function closeDragElement(e) {
        const destinationObject = sourceObject.getObjectByPoint(new Point(e.clientX, e.clientY), CirclesMap.get(line.StartId()));
        if (destinationObject != null) {
          const boundingCLient = destinationObject.canvas.getBoundingClientRect();
          const toX = boundingCLient.left + window.scrollX + destinationObject.canvas.offsetWidth / 2;
          const toY = boundingCLient.top + window.scrollY + destinationObject.canvas.offsetHeight / 2;
          line.End = new Point(toX, toY);
          line.Draw();
          line.EndId = destinationObject.id;
          destinationObject.lineId = line.Id();
          destinationObject.Draw();
          destinationObject.disconnectable();
          destinationObject.owner.OnConnect();
        } else {
          line.Remove();
          if (line.StartId() != "") {
            const startObject = CirclesMap.get(line.StartId());
            startObject.lineId = "";
            startObject.Draw();
          }
        }
        document.onmouseup = null;
        document.onmousemove = null;
      }
    }
    connectable() {
      const sourceObject = this;
      sourceObject.canvas.onmousedown = connectableMouseDown;
      let boundingCLient = sourceObject.canvas.getBoundingClientRect();
      let line;
      function connectableMouseDown(e) {
        e.preventDefault();
        if (sourceObject.isConnected() && LinesMap.get(sourceObject.lineId) != null) {
          return;
        }
        boundingCLient = sourceObject.canvas.getBoundingClientRect();
        const fromX = boundingCLient.left + window.scrollX + sourceObject.canvas.offsetWidth / 2;
        const fromY = boundingCLient.top + window.scrollY + sourceObject.canvas.offsetHeight / 2;
        line = new Line(new Point(fromX, fromY), new Point(e.clientX, e.clientY), sourceObject.id, sourceObject.style);
        LinesMap.set(line.Id(), line);
        sourceObject.lineId = line.Id();
        sourceObject.Draw();
        sourceObject.closeDraggable(line);
        sourceObject.draggable(line);
      }
    }
    disconnectable() {
      const sourceObject = this;
      sourceObject.canvas.onmousedown = disconnectableMouseDown;
      const line = LinesMap.get(sourceObject.lineId);
      if (line == null) {
        sourceObject.lineId = "";
        sourceObject.canvas.onmousedown = null;
        return;
      }
      function disconnectableMouseDown(e) {
        e.preventDefault();
        if (!sourceObject.isConnected()) {
          sourceObject.canvas.onmousedown = null;
          sourceObject.owner.OnDisconnect();
          return;
        }
        sourceObject.lineId = "";
        sourceObject.Draw();
        sourceObject.owner.OnDisconnect();
        sourceObject.closeDraggable(line);
        sourceObject.draggable(line);
        sourceObject.canvas.onmousedown = null;
      }
    }
  };

  // scripts/dest/Input.js
  function GetInputType(dataType) {
    switch (dataType) {
      case "int":
      case "int64":
      case "int32":
      case "int16":
      case "int8":
      case "uint":
      case "uint64":
      case "uint32":
      case "uint16":
      case "uint8":
      case "byte":
        return "number";
      case "string":
        return "text";
      case "bool":
        return "checkbox";
      case "float64":
      case "float32":
        return "number";
      case "date":
        return "date";
    }
    return "checkbox";
  }
  var Input = class {
    constructor(parent, id = "", type = "text", cssClasses = []) {
      this.element = document.createElement("input");
      this.element.id = id;
      this.element.type = type;
      this.element.classList.add(...cssClasses);
      parent.appendChild(this.element);
    }
  };

  // scripts/dest/FunctionInArgument.js
  var FunctionInArgument = class {
    constructor(dataType, parent) {
      this.id = NextArgument();
      const div = new Div(parent);
      const labelDiv = new Div(div.Element(), ["label"]);
      new Circle(labelDiv.Element(), parent.dataset.type, this, parent.id.slice(0, 5), dataType);
      new Label(labelDiv.Element(), dataType, this.id);
      const inputDiv = new Div(div.Element(), ["input"]);
      new Input(inputDiv.Element(), this.id, GetInputType(dataType));
      this.mainDiv = div.Element();
    }
    OnConnect() {
      document.getElementById(this.id).hidden = true;
    }
    OnDisconnect() {
      document.getElementById(this.id).hidden = false;
    }
    OnRemove() {
      this.mainDiv.parentElement.removeChild(this.mainDiv);
    }
  };

  // scripts/dest/Menus.js
  var Menus = class {
    constructor() {
      this.onHiddenCallabacks = [];
      this.shouldHideCallbacks = [];
      this.menus = document.getElementById("menus");
      this.handleMenus(this.menus);
      console.log("menus", this.menus);
    }
    static Instance() {
      if (!Menus.instance) {
        Menus.instance = new Menus();
      }
      return Menus.instance;
    }
    IsHidden(menuName) {
      return document.getElementById(menuName).hidden;
    }
    AddOnHidden(callback) {
      this.onHiddenCallabacks.push(callback);
    }
    AddShouldHide(callback) {
      this.shouldHideCallbacks.push(callback);
    }
    checkForShouldHide(target) {
      for (const cb of this.shouldHideCallbacks) {
        if (!cb(target)) {
          return false;
        }
      }
      return true;
    }
    ShowMenu(menuName, pos) {
      for (const cb of this.onHiddenCallabacks) {
        cb();
      }
      for (const child of this.menus.children) {
        child.hidden = true;
      }
      this.menus.hidden = false;
      let menu = document.getElementById(menuName);
      menu.hidden = false;
      setTimeout(() => {
        menu.classList.add("active");
      }, 50);
      this.menus.style.top = pos.Y + "px";
      this.menus.style.left = pos.X + "px";
      this.handleLeftClick();
    }
    handleLeftClick() {
      const selfObject = this;
      document.onmousedown = leftClick;
      function leftClick(e) {
        if (e.button == 0) {
          if (e.target == null || selfObject.checkForShouldHide(e.target) && !IsElementOrChild(e.target, selfObject.menus)) {
            e.preventDefault();
            selfObject.HideMenus();
          }
        }
      }
    }
    HideMenus() {
      for (const cb of this.onHiddenCallabacks) {
        cb();
      }
      setTimeout(() => {
        this.menus.hidden = true;
      }, 250);
      this.hideMenuChildren();
      document.onmousedown = null;
    }
    hideMenuChildren() {
      setTimeout(() => {
        this.menus.hidden = true;
      }, 250);
      for (const child of this.menus.children) {
        child.classList.remove("active");
      }
    }
    handleMenus(menus) {
      document.oncontextmenu = showMenu;
      const selfObject = this;
      function showMenu(e) {
        e.preventDefault();
        console.log("showMenu");
        if (IsNodeOrChildOfNode(e.target)) {
          console.log("showMenu - return");
          return;
        }
        for (const cb of selfObject.onHiddenCallabacks) {
          cb();
        }
        for (const child of menus.children) {
          child.hidden = true;
        }
        menus.hidden = false;
        let mainMenu = document.getElementById("main-menu");
        mainMenu.hidden = false;
        setTimeout(() => {
          mainMenu.classList.add("active");
        }, 50);
        menus.style.top = e.clientY + "px";
        menus.style.left = e.clientX + "px";
        selfObject.handleLeftClick();
      }
    }
  };
  Menus.instance = null;

  // scripts/dest/Plus.js
  var plusAmount = 0;
  var Plus = class {
    constructor(parent, onClick) {
      this.HasMenu = false;
      this.id = "plus" + ++plusAmount;
      this.parent = parent;
      this.canvas = document.createElement("canvas");
      this.canvas.id = this.id;
      ApplySize(this.canvas, canvasSize * 3);
      this.canvas.classList.add("canvasargument");
      parent.appendChild(this.canvas);
      this.canvas.onmouseover = () => {
        this.draw(true);
      };
      this.canvas.onmouseleave = () => {
        this.draw(false);
      };
      this.canvas.onclick = () => {
        onClick(this);
      };
      this.Draw();
      Menus.Instance().AddOnHidden(() => {
        this.HasMenu = false;
      });
      Menus.Instance().AddShouldHide((target) => {
        return target != this.canvas;
      });
    }
    Draw() {
      this.draw(false);
    }
    draw(fill) {
      this.Clear();
      const ctx = this.canvas.getContext("2d");
      ApplyStyle(ctx, 1);
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(25, 10);
      ctx.lineTo(35, 10);
      ctx.lineTo(35, 25);
      ctx.lineTo(50, 25);
      ctx.lineTo(50, 35);
      ctx.lineTo(35, 35);
      ctx.lineTo(35, 35);
      ctx.lineTo(35, 50);
      ctx.lineTo(25, 50);
      ctx.lineTo(25, 35);
      ctx.lineTo(10, 35);
      ctx.lineTo(10, 25);
      ctx.lineTo(25, 25);
      ctx.lineTo(25, 10);
      if (fill) {
        ctx.fill();
      } else {
        ctx.stroke();
      }
    }
    Element() {
      return this.canvas;
    }
    Clear() {
      const ctx = this.canvas.getContext("2d");
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    Id() {
      return this.id;
    }
    RemoveFromDom() {
      this.parent.removeChild(this.canvas);
    }
    AddToDom() {
      this.parent.appendChild(this.canvas);
    }
    Pos() {
      const srcBoundingCLient = this.canvas.getBoundingClientRect();
      return new Point(srcBoundingCLient.left + window.scrollX, srcBoundingCLient.top + window.scrollY);
    }
  };

  // scripts/dest/FunctionInPlus.js
  var FunctionInPlus = class {
    constructor(parent) {
      new Plus(parent, this.onClick);
    }
    onClick(plus) {
      console.log("plus clicked", plus.Id());
      const isHidden = Menus.Instance().IsHidden("menu-add-argument");
      if (isHidden || !plus.HasMenu) {
        Menus.Instance().ShowMenu("menu-add-argument", plus.Pos());
        this.handleOkButton(plus);
        plus.HasMenu = true;
      }
    }
    handleOkButton(_plus) {
      document.getElementById("menu-add-argument-button").onclick = handleClick;
      function handleClick(e) {
        e.preventDefault();
        console.log("ok");
      }
    }
  };

  // scripts/dest/FunctionOutArgument.js
  var FunctionOutArgument = class {
    constructor(dataType, parent) {
      this.id = NextArgument();
      const div = new Div(parent);
      const labelDiv = new Div(div.Element(), ["label"]);
      new Label(labelDiv.Element(), dataType);
      new Circle(labelDiv.Element(), parent.dataset.type, this, parent.id.slice(0, 5), dataType);
      this.mainDiv = div.Element();
    }
    OnConnect() {
      document.getElementById(this.id).hidden = true;
    }
    OnDisconnect() {
      document.getElementById(this.id).hidden = false;
    }
    OnRemove() {
      this.mainDiv.parentElement.removeChild(this.mainDiv);
    }
  };

  // scripts/dest/FunctionOutPlus.js
  var FunctionOutPlus = class {
    constructor(parent) {
      new Plus(parent, this.onClick);
    }
    onClick(plus) {
      console.log("plus clicked", plus.Id());
      const isHidden = Menus.Instance().IsHidden("menu-add-argument");
      if (isHidden || !plus.HasMenu) {
        Menus.Instance().ShowMenu("menu-add-argument", plus.Pos());
        this.handleOkButton(plus);
        plus.HasMenu = true;
      }
    }
    handleOkButton(_plus) {
      document.getElementById("menu-add-argument-button").onclick = handleClick;
      function handleClick(e) {
        e.preventDefault();
        console.log("ok");
      }
    }
  };

  // scripts/dest/main.js
  window.addEventListener("DOMContentLoaded", () => {
    DragElement(document.getElementById("node1"));
    DragElement(document.getElementById("node2"));
    Menus.Instance();
    const node1input = document.getElementById("node1-input");
    const node1output = document.getElementById("node1-output");
    const node2input = document.getElementById("node2-input");
    const node2output = document.getElementById("node2-output");
    new Arrow(node1input);
    new Arrow(node1output);
    new Arrow(node2input);
    new Arrow(node2output);
    new FunctionInArgument("int64", node1input);
    new FunctionInArgument("date", node1input);
    new FunctionOutArgument("bool", node1output);
    new FunctionInArgument("float64", node2input);
    new FunctionInArgument("bool", node2input);
    new FunctionOutArgument("int", node2output);
    new FunctionInPlus(node1input);
    new FunctionOutPlus(node1output);
    new FunctionInPlus(node2input);
    new FunctionOutPlus(node2output);
  });
})();
