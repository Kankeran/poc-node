"use strict";
(() => {
  // scripts/dest/Common.js
  var canvasSize = 20;
  var inType = "in";
  var outType = "out";
  var afterDragUpdaters = [];
  function applyStyle(ctx, styleId) {
    switch (styleId) {
      case 0: {
        ctx.strokeStyle = "white";
        ctx.fillStyle = "white";
        break;
      }
      case 1: {
        ctx.strokeStyle = "#b0b0b010";
        ctx.fillStyle = "#b0b0b070";
        break;
      }
      case 2: {
        ctx.strokeStyle = "red";
        ctx.fillStyle = "red";
        break;
      }
    }
  }
  function applySize(canvas, size) {
    canvas.width = size;
    canvas.height = size;
  }
  function afterDrag() {
    for (let updater of afterDragUpdaters) {
      updater.Update();
    }
  }
  function dragElement(element) {
    var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    document.getElementById(element.id + "header").onmousedown = dragMouseDown;
    function dragMouseDown(e) {
      e.preventDefault();
      pos3 = e.clientX;
      pos4 = e.clientY;
      document.onmouseup = closeDragElement;
      document.onmousemove = elementDrag;
    }
    function elementDrag(e) {
      e.preventDefault();
      pos1 = pos3 - e.clientX;
      pos2 = pos4 - e.clientY;
      pos3 = e.clientX;
      pos4 = e.clientY;
      element.style.top = element.offsetTop - pos2 + "px";
      element.style.left = element.offsetLeft - pos1 + "px";
      afterDrag();
    }
    function closeDragElement() {
      document.onmouseup = null;
      document.onmousemove = null;
    }
  }

  // scripts/dest/Line.js
  var lineAmount = 0;
  var LinesMap = /* @__PURE__ */ new Map();
  var Line = class {
    constructor(start, end, startId, style) {
      this.EndId = "";
      this.id = "line" + ++lineAmount;
      this.Start = start;
      this.End = end;
      this.canvas = document.createElement("canvas");
      this.startId = startId;
      this.style = style;
      this.canvas.id = this.id;
      this.canvas.style.position = "absolute";
      this.canvas.style.left = start.X - 30 + "px";
      this.canvas.style.top = start.Y - 30 + "px";
      this.canvas.width = Math.abs(end.X - start.X) * 2;
      this.canvas.height = Math.abs(end.Y - start.Y) * 2;
      document.body.appendChild(this.canvas);
      this.Draw();
      LinesMap.set(this.id, this);
    }
    Draw() {
      this.Clear();
      const width = Math.abs(this.End.X - this.Start.X) * 2;
      const height = Math.abs(this.End.Y - this.Start.Y) * 2;
      this.canvas.width = width + 200;
      this.canvas.height = height + 100;
      this.canvas.style.left = this.Start.X - this.canvas.width / 2 + "px";
      this.canvas.style.top = this.Start.Y - this.canvas.height / 2 + "px";
      const ctx = this.canvas.getContext("2d");
      applyStyle(ctx, this.style);
      ctx.lineWidth = 3;
      let x1 = this.canvas.width / 2, y1 = this.canvas.height / 2, x2 = x1 + this.End.X - this.Start.X, y2 = y1 + this.End.Y - this.Start.Y;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      if (x1 >= x2) {
        let xDistance = (x1 - x2) / 2;
        let x3 = x1 - xDistance;
        let y3 = y2 - (y2 - y1) / 2;
        xDistance = xDistance > 40 ? 80 : xDistance * 2;
        ctx.bezierCurveTo(x1 + xDistance, y1, x1 + xDistance, y3, x3, y3);
        ctx.bezierCurveTo(x2 - xDistance, y3, x2 - xDistance, y2, x2, y2);
      } else {
        ctx.bezierCurveTo(x1 + (x2 - x1) / 4 * 3, y1, x1 + (x2 - x1) / 4, y2, x2, y2);
      }
      ctx.stroke();
    }
    Element() {
      return this.canvas;
    }
    Clear() {
      const ctx = this.canvas.getContext("2d");
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    Remove() {
      this.canvas.parentElement.removeChild(this.canvas);
      LinesMap.delete(this.id);
    }
    Id() {
      return this.id;
    }
    StartId() {
      return this.startId;
    }
  };

  // scripts/dest/Point.js
  var Point = class {
    constructor(x, y) {
      this.X = x;
      this.Y = y;
    }
  };

  // scripts/dest/Arrow.js
  var arrowAmount = 0;
  var ArrowsMap = /* @__PURE__ */ new Map();
  var Arrow = class {
    constructor(parent) {
      this.style = 0;
      this.lineId = "";
      this.id = "arrow" + ++arrowAmount;
      this.type = parent.dataset.type;
      this.canvas = document.createElement("canvas");
      this.canvas.id = this.id;
      applySize(this.canvas, canvasSize * 3);
      this.canvas.classList.add("canvasargument");
      parent.appendChild(this.canvas);
      this.Draw();
      ArrowsMap.set(this.id, this);
      if (this.type == outType) {
        this.connectable();
      }
      afterDragUpdaters.push(this);
    }
    Draw() {
      this.Clear();
      const ctx = this.canvas.getContext("2d");
      applyStyle(ctx, 0);
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(10, 10);
      ctx.lineTo(30, 10);
      ctx.lineTo(50, 30);
      ctx.lineTo(30, 50);
      ctx.lineTo(10, 50);
      ctx.lineTo(10, 10);
      if (this.isConnected()) {
        ctx.fill();
      } else {
        ctx.stroke();
      }
    }
    Element() {
      return this.canvas;
    }
    isConnected() {
      return this.lineId != "";
    }
    canConnect() {
      return this.type == inType;
    }
    Clear() {
      const ctx = this.canvas.getContext("2d");
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    Id() {
      return this.id;
    }
    Update() {
      if (this.lineId == "") {
        return;
      }
      const line = LinesMap.get(this.lineId);
      const sourceObject = ArrowsMap.get(line.StartId());
      const srcBoundingCLient = sourceObject.canvas.getBoundingClientRect();
      const fromX = srcBoundingCLient.left + window.scrollX + sourceObject.canvas.offsetWidth / 2;
      const fromY = srcBoundingCLient.top + window.scrollY + sourceObject.canvas.offsetHeight / 2;
      line.Start = new Point(fromX, fromY);
      const destinationObject = ArrowsMap.get(line.EndId);
      const destBoundingCLient = destinationObject.canvas.getBoundingClientRect();
      const toX = destBoundingCLient.left + window.scrollX + destinationObject.canvas.offsetWidth / 2;
      const toY = destBoundingCLient.top + window.scrollY + destinationObject.canvas.offsetHeight / 2;
      line.End = new Point(toX, toY);
      line.Draw();
    }
    getObjectByPoint(point) {
      for (const [_, arrow] of ArrowsMap) {
        const boundingCLient = arrow.canvas.getBoundingClientRect();
        if (arrow.canConnect() && point.X > boundingCLient.left + window.scrollX && point.X < boundingCLient.right + window.scrollX && point.Y > boundingCLient.top + window.scrollY && point.Y < boundingCLient.bottom + window.scrollY) {
          return arrow;
        }
      }
      return null;
    }
    draggable(line) {
      document.onmousemove = elementDrag;
      function elementDrag(e) {
        e.preventDefault();
        line.End = new Point(e.clientX, e.clientY);
        line.Draw();
      }
    }
    closeDraggable(line) {
      const sourceObject = this;
      document.onmouseup = closeDragElement;
      function closeDragElement(e) {
        const destinationObject = sourceObject.getObjectByPoint(new Point(e.clientX, e.clientY));
        if (destinationObject != null) {
          const boundingCLient = destinationObject.canvas.getBoundingClientRect();
          const toX = boundingCLient.left + window.scrollX + sourceObject.canvas.offsetWidth / 2;
          const toY = boundingCLient.top + window.scrollY + sourceObject.canvas.offsetHeight / 2;
          line.End = new Point(toX, toY);
          line.Draw();
          line.EndId = destinationObject.id;
          destinationObject.lineId = line.Id();
          destinationObject.Draw();
          destinationObject.disconnectable();
        } else {
          line.Remove();
          if (line.StartId() != "") {
            const startObject = ArrowsMap.get(line.StartId());
            startObject.lineId = "";
            startObject.Draw();
          }
        }
        document.onmouseup = null;
        document.onmousemove = null;
      }
    }
    connectable() {
      const sourceObject = this;
      sourceObject.canvas.onmousedown = connectableMouseDown;
      let boundingCLient = sourceObject.canvas.getBoundingClientRect();
      let line;
      function connectableMouseDown(e) {
        e.preventDefault();
        if (sourceObject.isConnected() && LinesMap.get(sourceObject.lineId) != null) {
          return;
        }
        boundingCLient = sourceObject.canvas.getBoundingClientRect();
        const fromX = boundingCLient.left + window.scrollX + sourceObject.canvas.offsetWidth / 2;
        const fromY = boundingCLient.top + window.scrollY + sourceObject.canvas.offsetHeight / 2;
        line = new Line(new Point(fromX, fromY), new Point(e.clientX, e.clientY), sourceObject.id, sourceObject.style);
        LinesMap.set(line.Id(), line);
        sourceObject.lineId = line.Id();
        sourceObject.Draw();
        sourceObject.closeDraggable(line);
        sourceObject.draggable(line);
      }
    }
    disconnectable() {
      const sourceObject = this;
      sourceObject.canvas.onmousedown = disconnectableMouseDown;
      const line = LinesMap.get(sourceObject.lineId);
      if (line == null) {
        sourceObject.lineId = "";
        sourceObject.canvas.onmousedown = null;
        return;
      }
      function disconnectableMouseDown(e) {
        e.preventDefault();
        if (!sourceObject.isConnected()) {
          sourceObject.canvas.onmousedown = null;
          return;
        }
        sourceObject.lineId = "";
        sourceObject.Draw();
        sourceObject.closeDraggable(line);
        sourceObject.draggable(line);
        sourceObject.canvas.onmousedown = null;
      }
    }
  };

  // scripts/dest/Plus.js
  var plusAmount = 0;
  var Plus = class {
    constructor(parent) {
      this.id = "plus" + ++plusAmount;
      this.canvas = document.createElement("canvas");
      this.canvas.id = this.id;
      applySize(this.canvas, canvasSize * 3);
      this.canvas.classList.add("canvasargument");
      parent.appendChild(this.canvas);
      this.canvas.onmouseover = () => {
        this.draw(true);
      };
      this.canvas.onmouseleave = () => {
        this.draw(false);
      };
      this.Draw();
    }
    Draw() {
      this.draw(false);
    }
    draw(fill) {
      this.Clear();
      const ctx = this.canvas.getContext("2d");
      applyStyle(ctx, 1);
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(25, 10);
      ctx.lineTo(35, 10);
      ctx.lineTo(35, 25);
      ctx.lineTo(50, 25);
      ctx.lineTo(50, 35);
      ctx.lineTo(35, 35);
      ctx.lineTo(35, 35);
      ctx.lineTo(35, 50);
      ctx.lineTo(25, 50);
      ctx.lineTo(25, 35);
      ctx.lineTo(10, 35);
      ctx.lineTo(10, 25);
      ctx.lineTo(25, 25);
      ctx.lineTo(25, 10);
      if (fill) {
        ctx.fill();
      } else {
        ctx.stroke();
      }
    }
    Element() {
      return this.canvas;
    }
    Clear() {
      const ctx = this.canvas.getContext("2d");
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    Id() {
      return this.id;
    }
  };

  // scripts/dest/Circle.js
  var circleAmount = 0;
  var CirclesMap = /* @__PURE__ */ new Map();
  var Circle = class {
    constructor(parent, type, onConnector) {
      this.style = 2;
      this.lineId = "";
      this.id = "circle" + ++circleAmount;
      this.type = type;
      this.onConnector = onConnector;
      document.createElement("div");
      this.canvas = document.createElement("canvas");
      this.canvas.id = this.id;
      applySize(this.canvas, canvasSize * 3);
      this.canvas.classList.add("canvasargument");
      parent.appendChild(this.canvas);
      this.Draw();
      CirclesMap.set(this.id, this);
      if (this.type == outType) {
        this.connectable();
      }
      afterDragUpdaters.push(this);
    }
    Draw() {
      this.Clear();
      const ctx = this.canvas.getContext("2d");
      applyStyle(ctx, this.style);
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(canvasSize * 1.5, canvasSize * 1.5, canvasSize, 0, 2 * Math.PI);
      if (this.isConnected()) {
        ctx.fill();
      } else {
        ctx.stroke();
      }
    }
    isConnected() {
      return this.lineId != "";
    }
    canConnect() {
      return this.type == inType;
    }
    Element() {
      return this.canvas;
    }
    Clear() {
      const ctx = this.canvas.getContext("2d");
      ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
    Id() {
      return this.id;
    }
    Update() {
      if (this.lineId == "") {
        return;
      }
      const line = LinesMap.get(this.lineId);
      const sourceObject = CirclesMap.get(line.StartId());
      const srcBoundingCLient = sourceObject.canvas.getBoundingClientRect();
      const fromX = srcBoundingCLient.left + window.scrollX + sourceObject.canvas.offsetWidth / 2;
      const fromY = srcBoundingCLient.top + window.scrollY + sourceObject.canvas.offsetHeight / 2;
      line.Start = new Point(fromX, fromY);
      const destinationObject = CirclesMap.get(line.EndId);
      const destBoundingCLient = destinationObject.canvas.getBoundingClientRect();
      const toX = destBoundingCLient.left + window.scrollX + destinationObject.canvas.offsetWidth / 2;
      const toY = destBoundingCLient.top + window.scrollY + destinationObject.canvas.offsetHeight / 2;
      line.End = new Point(toX, toY);
      line.Draw();
    }
    getObjectByPoint(point) {
      for (const [_, circle] of CirclesMap) {
        const boundingCLient = circle.canvas.getBoundingClientRect();
        if (circle.canConnect() && point.X > boundingCLient.left + window.scrollX && point.X < boundingCLient.right + window.scrollX && point.Y > boundingCLient.top + window.scrollY && point.Y < boundingCLient.bottom + window.scrollY) {
          return circle;
        }
      }
      return null;
    }
    draggable(line) {
      document.onmousemove = elementDrag;
      function elementDrag(e) {
        e.preventDefault();
        line.End = new Point(e.clientX, e.clientY);
        line.Draw();
      }
    }
    closeDraggable(line) {
      const sourceObject = this;
      document.onmouseup = closeDragElement;
      function closeDragElement(e) {
        const destinationObject = sourceObject.getObjectByPoint(new Point(e.clientX, e.clientY));
        if (destinationObject != null) {
          const boundingCLient = destinationObject.canvas.getBoundingClientRect();
          const toX = boundingCLient.left + window.scrollX + destinationObject.canvas.offsetWidth / 2;
          const toY = boundingCLient.top + window.scrollY + destinationObject.canvas.offsetHeight / 2;
          line.End = new Point(toX, toY);
          line.Draw();
          line.EndId = destinationObject.id;
          destinationObject.lineId = line.Id();
          destinationObject.Draw();
          destinationObject.disconnectable();
          destinationObject.onConnector.OnConnect();
        } else {
          line.Remove();
          if (line.StartId() != "") {
            const startObject = CirclesMap.get(line.StartId());
            startObject.lineId = "";
            startObject.Draw();
          }
        }
        document.onmouseup = null;
        document.onmousemove = null;
      }
    }
    connectable() {
      const sourceObject = this;
      sourceObject.canvas.onmousedown = connectableMouseDown;
      let boundingCLient = sourceObject.canvas.getBoundingClientRect();
      let line;
      function connectableMouseDown(e) {
        e.preventDefault();
        if (sourceObject.isConnected() && LinesMap.get(sourceObject.lineId) != null) {
          return;
        }
        boundingCLient = sourceObject.canvas.getBoundingClientRect();
        const fromX = boundingCLient.left + window.scrollX + sourceObject.canvas.offsetWidth / 2;
        const fromY = boundingCLient.top + window.scrollY + sourceObject.canvas.offsetHeight / 2;
        line = new Line(new Point(fromX, fromY), new Point(e.clientX, e.clientY), sourceObject.id, sourceObject.style);
        LinesMap.set(line.Id(), line);
        sourceObject.lineId = line.Id();
        sourceObject.Draw();
        sourceObject.closeDraggable(line);
        sourceObject.draggable(line);
      }
    }
    disconnectable() {
      const sourceObject = this;
      sourceObject.canvas.onmousedown = disconnectableMouseDown;
      const line = LinesMap.get(sourceObject.lineId);
      if (line == null) {
        sourceObject.lineId = "";
        sourceObject.canvas.onmousedown = null;
        return;
      }
      function disconnectableMouseDown(e) {
        e.preventDefault();
        if (!sourceObject.isConnected()) {
          sourceObject.canvas.onmousedown = null;
          sourceObject.onConnector.OnDisconnect();
          return;
        }
        sourceObject.lineId = "";
        sourceObject.Draw();
        sourceObject.onConnector.OnDisconnect();
        sourceObject.closeDraggable(line);
        sourceObject.draggable(line);
        sourceObject.canvas.onmousedown = null;
      }
    }
  };

  // scripts/dest/Argument.js
  var argumentAmount = 0;
  var Argument = class {
    constructor(dataType, parent) {
      this.dataType = dataType;
      this.id = "argument" + ++argumentAmount;
      if (parent.dataset.type == inType) {
        parent.appendChild(this.createInDiv(parent.dataset.type));
      } else {
        parent.appendChild(this.createOutDiv(parent.dataset.type));
      }
    }
    createInDiv(type) {
      let div = document.createElement("div");
      let labelDiv = document.createElement("div");
      labelDiv.classList.add("label");
      new Circle(labelDiv, type, this);
      let label = document.createElement("label");
      label.innerHTML = this.dataType;
      label.setAttribute("for", this.id);
      labelDiv.appendChild(label);
      div.appendChild(labelDiv);
      let inputDiv = document.createElement("div");
      inputDiv.classList.add("input");
      let input = document.createElement("input");
      input.type = this.getType();
      input.id = this.id;
      inputDiv.appendChild(input);
      div.appendChild(inputDiv);
      return div;
    }
    createOutDiv(type) {
      let div = document.createElement("div");
      let labelDiv = document.createElement("div");
      labelDiv.classList.add("label");
      let label = document.createElement("label");
      label.innerHTML = this.dataType;
      labelDiv.appendChild(label);
      new Circle(labelDiv, type, this);
      div.appendChild(labelDiv);
      return div;
    }
    getType() {
      switch (this.dataType) {
        case "int":
          return "number";
      }
      return "checkbox";
    }
    OnConnect() {
      document.getElementById(this.id).hidden = true;
    }
    OnDisconnect() {
      document.getElementById(this.id).hidden = false;
    }
  };

  // scripts/dest/main.js
  window.addEventListener("DOMContentLoaded", () => {
    dragElement(document.getElementById("node1"));
    dragElement(document.getElementById("node2"));
    handleMenus();
    const node1input = document.getElementById("node1input");
    const node1output = document.getElementById("node1output");
    const node2input = document.getElementById("node2input");
    const node2output = document.getElementById("node2output");
    new Arrow(node1input);
    new Arrow(node1output);
    new Arrow(node2input);
    new Arrow(node2output);
    new Argument("int", node1input);
    new Argument("int", node1input);
    new Argument("int", node1output);
    new Argument("int", node2input);
    new Argument("int", node2input);
    new Argument("int", node2output);
    new Plus(node1input);
    new Plus(node1output);
    new Plus(node2input);
    new Plus(node2output);
  });
  function handleMenus() {
    const menus = document.getElementById("menus");
    document.oncontextmenu = showMenu;
    document.onmousedown = leftClick;
    function showMenu(e) {
      e.preventDefault();
      menus.hidden = false;
      let mainMenu = document.getElementById("mainmenu");
      mainMenu.hidden = false;
      setTimeout(() => {
        mainMenu.classList.add("active");
      }, 50);
      menus.style.top = e.clientY + "px";
      menus.style.left = e.clientX + "px";
    }
    function leftClick(e) {
      e.preventDefault();
      if (e.button == 0) {
        if (e.target == null || !isElementOrChild(e.target, menus)) {
          hideMenus();
        }
      }
    }
    function hideMenus() {
      setTimeout(() => {
        menus.hidden = true;
        for (const child of menus.children) {
          child.hidden = true;
        }
      }, 250);
      for (const child of menus.children) {
        child.classList.remove("active");
      }
    }
  }
  function isElementOrChild(wanted, element) {
    if (wanted == element) {
      return true;
    }
    if (!element.hasChildNodes()) {
      return false;
    }
    for (const child of element.children) {
      if (isElementOrChild(wanted, child)) {
        return true;
      }
    }
    return false;
  }
})();
